#!/usr/bin/env python

"""hsc-vs-decals --clobber

Run the legacyhalos pipeline on the HSC vs DECaLS comparison sample.

"""
import os, argparse, sys, pickle
import pdb
import numpy as np
import fitsio
from astropy.table import Table, hstack

import matplotlib.pyplot as plt

import legacyhalos.io
import legacyhalos.qa
import legacyhalos.html
import legacyhalos.coadds
from legacyhalos.ellipse import ellipse_sbprofile
from legacyhalos.misc import cutout_radius_150kpc

from astrometry.util.multiproc import multiproc
from astrometry.util.fits import fits_table, merge_tables

sns, setcolors = legacyhalos.misc.plot_style()

PIXSCALE = 0.262

def _missing(sample, size=1, filetype='coadds', clobber=False):
    """Find missing data of a given filetype."""    

    if filetype == 'coadds':
        filesuffix = 'image-central.jpg'
    elif filetype == 'ellipse':
        filesuffix = 'ellipsefit.p'
    elif filetype == 'sersic':
        filesuffix = 'sersic-single.p'
    elif filetype == 'sky':
        filesuffix = 'ellipsefit-sky.p'
    else:
        print('Unrecognized file type!')
        raise ValueError

    objdir = '.'
    objid = sample['GALAXY']

    ngal = len(sample)
    indices = np.arange(ngal)
    todo = np.ones(ngal, dtype=bool)
    
    for ii, (objid1, objdir1) in enumerate( zip(np.atleast_1d(objid), np.atleast_1d(objdir)) ):
        residfile = os.path.join(objdir1, '{}-{}'.format(objid1, filesuffix))
        if os.path.exists(residfile) and clobber is False:
            todo[ii] = False

    if np.sum(todo) == 0:
        return list()
    else:
        indices = indices[todo]
    return np.array_split(indices, size)

def missing_coadds(sample, size=1, clobber=False):
    '''Find the galaxies that do not yet have coadds.'''
    return _missing(sample, size=size, filetype='coadds',
                    clobber=clobber)

def missing_ellipse(sample, size=1, clobber=False):
    '''Find the galaxies that do not yet have ellipse fits.'''
    return _missing(sample, size=size, filetype='ellipse',
                    clobber=clobber)

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--ncpu', default=4, type=int, help='number of multiprocessing processes per MPI rank.')
    parser.add_argument('--pixscale', default=0.262, type=float, help='pixel scale (arcsec/pix).')

    parser.add_argument('--build-sample', action='store_true', help='Build and write out the sample.')
    parser.add_argument('--coadds', action='store_true', help='Build the custom coadds')
    parser.add_argument('--ellipse', action='store_true', help='Do the ellipse fitting.')
    parser.add_argument('--force', action='store_true', help='Use with --coadds; ignore previous pickle files.')
    parser.add_argument('--count', action='store_true', help='Count how many objects are left to analyze and then return.')
    parser.add_argument('--debug', action='store_true', help='Log to STDOUT and build debugging plots.')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output.')
    parser.add_argument('--clobber', action='store_true', help='Overwrite existing files.')                                
    args = parser.parse_args()

    # Write out the sample.
    if args.build_sample:
        from astrometry.libkd.spherematch import match_radec

        # Really should be reading this from disk.
        cat = Table()
        cat['GALAXY'] = np.array(['CGCG004-096'])
        cat['RA'] = np.array([129.603676]).astype('f8')
        cat['DEC'] = np.array([-1.606419]).astype('f8')
        cat['Z'] = np.array([0.05204]).astype('f4')
        
        brickname = '1296m015' # hard-coded
        tractorfile = os.path.join(os.getenv('LEGACY_SURVEY_DIR'), 'tractor', brickname[:3],
                                   'tractor-{}.fits'.format(brickname))
        print('Reading {}'.format(tractorfile))
        tractor = Table(fitsio.read(tractorfile, upper=True))
        m1, m2, d12 = match_radec(cat['RA'], cat['DEC'], tractor['RA'], tractor['DEC'], 1/3600, nearest=True)

        sample = hstack( (cat['GALAXY', 'Z'], tractor[m1]) )
        sample.rename_column('GALAXY', 'CENTRAL_ID')

        samplefile = os.path.join( legacyhalos.io.hsc_vs_decals_dir(), 'hsc-vs-decals.fits' )
        print('Writing {}'.format(samplefile))
        sample.write(samplefile, overwrite=True)

        sys.exit(1)

    

    from legacypipe.survey import LegacySurveyData
    survey = LegacySurveyData()
    survey.output_dir = '.'


    log = None
    #force = True
    force = False
    splinesky = True
    #ncpu = 1
    ncpu = 16

    mp = multiproc(nthreads=ncpu)

    from scipy.ndimage.morphology import binary_dilation
    from tractor.splinesky import SplineSky
    import matplotlib.patches as patches
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    from astropy.convolution import Gaussian2DKernel, convolve
    from legacypipe.image import CP_DQ_BITS
    from photutils import CircularAperture, CircularAnnulus, aperture_photometry

    for onegal in np.atleast_1d(sample):

        prefix = onegal['GALAXY']
        radius = cutout_radius_150kpc(redshift=onegal['Z'], pixscale=PIXSCALE)

        ccdsfile = os.path.join('.', '{}-ccds.fits'.format(prefix))
        ccds = fits_table(ccdsfile)

        if False:
            qaccdposfile = os.path.join('qa-{}-ccdpos.png'.format(prefix.lower()))
            legacyhalos.qa.ccdpos(onegal, ccds, png=qaccdposfile)

        tims = []
        for iccd, ccd in enumerate(ccds):
            im = survey.get_image_object(ccd)
            print(im, im.band, 'exptime', im.exptime, 'propid', ccd.propid,
                  'seeing {:.2f}'.format(ccd.fwhm*im.pixscale), 
                  'object', getattr(ccd, 'object', None))
            tim = im.get_tractor_image(splinesky=True, subsky=False,
                                       hybridPsf=True, normalizePsf=True)
            tims.append(tim)

            # Get the (pixel) coordinates of the galaxy on this CCD
            W, H, wcs = legacyhalos.misc.ccdwcs(ccd)
            ok, x0, y0 = wcs.radec2pixelxy(onegal['RA'], onegal['DEC'])
            xcen, ycen = x0 - 1, y0 - 1
            pxscale = wcs.pixel_scale()

            # Get the image, read and instantiate the splinesky model, and
            # also reproduce the image mask used in legacypipe.decam.run_calibs.
            image = tim.getImage()
            weight = tim.getInvvar()
            sky = tim.getSky()
            skymodel = np.zeros_like(image)
            sky.addTo(skymodel)

            med = np.median(image[weight > 0])
            skyobj = SplineSky.BlantonMethod(image - med, weight>0, 512)
            skymod = np.zeros_like(image)
            skyobj.addTo(skymod)
            sig1 = 1.0 / np.sqrt(np.median(weight[weight > 0]))
            mask = ((image - med - skymod) > (5.0*sig1))*1.0
            mask = binary_dilation(mask, iterations=3)
            mask[weight == 0] = 1 # 0=good, 1=bad
            pipeskypix = np.flatnonzero((mask == 0)*1)

            if False:
                # Make a more aggressive object mask but reset the badpix and
                # edge bits.
                print('Iteratively building a more aggressive object mask.')
                #newmask = ((image - med - skymod) > (3.0*sig1))*1.0
                newmask = mask.copy()
                #newmask = (weight == 0)*1 
                for bit in ('edge', 'edge2'):
                    ww = np.flatnonzero((tim.dq & CP_DQ_BITS[bit]) == CP_DQ_BITS[bit])
                    if len(ww) > 0:
                        newmask.flat[ww] = 0
                for jj in range(2):
                    gauss = Gaussian2DKernel(stddev=1)
                    newmask = convolve(newmask, gauss)
                    newmask[newmask > 0] = 1 # 0=good, 1=bad

            #http://stackoverflow.com/questions/8647024/how-to-apply-a-disc-shaped-mask-to-a-numpy-array
            ysize, xsize = image.shape
            ymask, xmask = np.ogrid[-ycen:ysize-ycen, -xcen:xsize-xcen]
            newmask = xmask**2 + ymask**2 <= radius**2

            newmask += mask
            newmask[newmask > 0] = 1

            # Build a new sky model.
            newskypix = np.flatnonzero((newmask == 0)*1)
            newmed = np.median(image.flat[newskypix]) # need mode with rejection
            newsky = np.zeros_like(image) + newmed
            #newsky = skymodel.copy()

            ## Now do a lower-order polynomial sky subtraction.
            #xall, yall = np.mgrid[:H, :W]
            #xx = xall.flat[newskypix]
            #yy = yall.flat[newskypix]
            #sky = image.flat[newskypix]
            #if False:
            #    plt.clf() ; plt.scatter(xx[:5000], sky[:5000]) ; plt.show()
            #    pdb.set_trace()
            #    pinit = models.Polynomial2D(degree=1)
            #    pfit = fitting.LevMarLSQFitter()
            #    coeff = pfit(pinit, xx, yy, sky)
            #    # evaluate the model back on xall, yall

            # Perform aperture photometry on the sky-subtracted images.
            image_nopipesky = image - skymodel
            image_nonewsky = image - newsky

            #import fitsio
            #fitsio.write('junk.fits', image_nopipesky)
            #x0 = 1000 # Hack!!!

            #with np.errstate(divide = 'ignore'):
            #    imsigma = 1.0/np.sqrt(weight)
            #    imsigma[weight == 0] = 0

            deltar = 5.0
            rin = np.arange(0.0, radius/2, 1.0)
            nap = len(rin)

            apphot = Table(np.zeros(nap, dtype=[('RCEN', 'f4'), ('RIN', 'f4'),
                                                ('ROUT', 'f4'), ('PIPEFLUX', 'f4'),
                                                ('NEWFLUX', 'f4'), ('PIPESKYFLUX', 'f4'), 
                                                ('NEWSKYFLUX', 'f4'), ('AREA', 'f4'),
                                                ('SKYAREA', 'f4')]))
            apphot['RIN'] = rin
            apphot['ROUT'] = rin + deltar
            apphot['RCEN'] = rin + deltar / 2.0
            for ii in range(nap):
                ap = CircularAperture((xcen, ycen), apphot['RCEN'][ii])
                skyap = CircularAnnulus((xcen, ycen), r_in=apphot['RIN'][ii],
                                        r_out=apphot['ROUT'][ii])

                #pdb.set_trace()
                apphot['PIPEFLUX'][ii] = aperture_photometry(image_nopipesky, ap)['aperture_sum'].data
                apphot['NEWFLUX'][ii] = aperture_photometry(image_nonewsky, ap)['aperture_sum'].data
                apphot['PIPESKYFLUX'][ii] = aperture_photometry(image_nopipesky, skyap)['aperture_sum'].data
                apphot['NEWSKYFLUX'][ii] = aperture_photometry(image_nonewsky, skyap)['aperture_sum'].data

                apphot['AREA'][ii] = ap.area()
                apphot['SKYAREA'][ii] = skyap.area()

            # Convert to arcseconds
            apphot['RIN'] *= im.pixscale
            apphot['ROUT'] *= im.pixscale
            apphot['RCEN'] *= im.pixscale
            apphot['AREA'] *= im.pixscale**2
            apphot['SKYAREA'] *= im.pixscale**2
            print(apphot)
            #pdb.set_trace()

            # Now generate some QAplots related to the sky.
            sbinsz = 0.001
            srange = (-5 * sig1, +5 * sig1)
            #sbins = 50
            sbins = np.int( (srange[1]-srange[0]) / sbinsz )

            qaccd = os.path.join('.', 'qa-{}-ccd{:02d}-sky.png'.format(prefix.lower(), iccd))
            fig, ax = plt.subplots(1, 2, figsize=(8, 4))
            fig.suptitle('{} (ccd{:02d})'.format(tim.name, iccd), y=0.97)
            for data1, label, color in zip((image_nopipesky.flat[pipeskypix],
                                            image_nonewsky.flat[newskypix]),
                                           ('Pipeline Sky', 'Custom Sky'), setcolors):
                nn, bins = np.histogram(data1, bins=sbins, range=srange)
                nn = nn/float(np.max(nn))
                cbins = (bins[:-1] + bins[1:]) / 2.0
                #pdb.set_trace()
                ax[0].step(cbins, nn, color=color, lw=2, label=label)
                ax[0].set_ylim(0, 1.2)
                #(nn, bins, _) = ax[0].hist(data1, range=srange, bins=sbins,
                #                           label=label, normed=True, lw=2, 
                #                           histtype='step', color=color)
            ylim = ax[0].get_ylim()
            ax[0].vlines(0.0, ylim[0], 1.05, colors='k', linestyles='dashed')
            ax[0].set_xlabel('Residuals (nmaggie)')
            ax[0].set_ylabel('Relative Fraction of Pixels')
            ax[0].legend(frameon=False, loc='upper left')

            ax[1].plot(apphot['RCEN'], apphot['PIPESKYFLUX']/apphot['SKYAREA'], 
                          label='Pipeline', color=setcolors[0])
            ax[1].plot(apphot['RCEN'], apphot['NEWSKYFLUX']/apphot['SKYAREA'], 
                          label='Custom', color=setcolors[1])
            #ax[1].scatter(apphot['RCEN'], apphot['PIPESKYFLUX']/apphot['SKYAREA'], 
            #              label='DR2 Pipeline', marker='o', color=setcolors[0])
            #ax[1].scatter(apphot['RCEN']+1.0, apphot['NEWSKYFLUX']/apphot['SKYAREA'], 
            #              label='Large Galaxy Pipeline', marker='s', color=setcolors[1])
            ax[1].set_xlabel('Galactocentric Radius (arcsec)')
            ax[1].set_ylabel('Flux in {:g}" Annulus (nmaggie/arcsec$^2$)'.format(deltar))
            ax[1].set_xlim(-2.0, apphot['ROUT'][-1])
            ax[1].legend(frameon=False, loc='upper right')

            xlim = ax[1].get_xlim()
            ylim = ax[1].get_ylim()
            ax[1].hlines(0.0, xlim[0], xlim[1]*0.99999, colors='k', linestyles='dashed')
            #ax[1].vlines(gal['RADIUS'], ylim[0], ylim[1]*0.5, colors='k', linestyles='dashed')

            plt.tight_layout(w_pad=0.25)
            plt.subplots_adjust(bottom=0.15, top=0.88)
            print('Writing {}'.format(qaccd))
            plt.savefig(qaccd)

            #print('Exiting prematurely!')
            #sys.exit(1)

            # Visualize the data, the mask, and the sky.
            qaccd = os.path.join('.', 'qa-{}-ccd{:02d}-2d.png'.format(prefix.lower(), iccd))
            fig, ax = plt.subplots(1, 5, sharey=True, figsize=(14, 4.5))
            #fig, ax = plt.subplots(3, 2, sharey=True, figsize=(14, 6))
            fig.suptitle('{} (ccd{:02d})'.format(tim.name, iccd), y=0.97)

            vmin_image, vmax_image = np.percentile(image, (1, 99))
            vmin_weight, vmax_weight = np.percentile(weight, (1, 99))
            vmin_mask, vmax_mask = (0, 1)
            vmin_sky, vmax_sky = np.percentile(skymodel, (1, 99))

            for thisax, data, title in zip(ax.flat, (image, mask, newmask, skymodel, newsky), 
                                           ('Image', 'Pipeline Mask', 'Custom Mask',
                                            'Pipeline Sky', 'Custom Sky')):
                if 'Mask' in title:
                    vmin, vmax = vmin_mask, vmax_mask
                elif 'Sky' in title:
                    vmin, vmax = vmin_sky, vmax_sky
                elif 'Image' in title:
                    vmin, vmax = vmin_image, vmax_image
                elif 'Weight' in title:
                    vmin, vmax = vmin_weight, vmax_weight

                thisim = thisax.imshow(data, cmap='inferno', interpolation='nearest', origin='lower',
                                       vmin=vmin, vmax=vmax)
                thisax.add_patch(patches.Circle((xcen, ycen), radius, fill=False, edgecolor='white', lw=2))
                div = make_axes_locatable(thisax)
                cax = div.append_axes('right', size='15%', pad=0.1)
                cbar = fig.colorbar(thisim, cax=cax, format='%.4g')

                thisax.set_title(title)
                thisax.xaxis.set_visible(False)
                thisax.yaxis.set_visible(False)
                thisax.set_aspect('equal')

            ## Shared colorbar.
            plt.tight_layout(w_pad=0.25, h_pad=0.25)
            plt.subplots_adjust(bottom=0.0, top=0.93)
            print('Writing {}'.format(qaccd))
            plt.savefig(qaccd)


            pdb.set_trace()

        if len(missing_coadds(sample, clobber=True)) > 0:
            brickname = legacyhalos.coadds.custom_brickname(onegal['RA'], onegal['DEC'], prefix='')

            P = legacyhalos.coadds.coadds_stage_tims(onegal, survey=survey, mp=mp, radius=radius,
                                                     brickname=brickname, pixscale=PIXSCALE,
                                                     log=log, splinesky=splinesky, plots=True)
            
            
            
            pdb.set_trace()

            # Step 1 - Build a custom brick.
            success = legacyhalos.coadds.custom_brick(onegal, prefix, survey=survey, radius=radius,
                                                      ncpu=ncpu, pixscale=PIXSCALE, log=log, force=force,
                                                      archivedir=None, splinesky=splinesky)

            if success:
                # Step 2 - Read the Tractor catalog for this brick and remove the central.
                cat = legacyhalos.coadds.read_tractor(onegal, prefix=prefix, survey=survey, log=log)

                # Step 3 - Set up the first stage of the pipeline.
                P = legacyhalos.coadds.coadds_stage_tims(onegal, survey=survey, mp=mp, radius=radius,
                                                         brickname=brickname, pixscale=PIXSCALE,
                                                         log=log, splinesky=splinesky)

                ## To get the sky models:
                #tim = P['tims'][0]
                #sky = tim.imobj.read_sky_model(splinesky=True, slc=tim.slice)
                #skymod = np.zeros(tim.shape, np.float32)
                #sky.addTo(skymod)
                #import matplotlib.pyplot as plt
                #plt.imshow(skymod, origin='lower')
                #plt.show()

                # Step 4 - Render the model images without the central.
                mods = legacyhalos.coadds.build_model_image(cat, tims=P['tims'], survey=survey, log=log)

                # Step 3 - Generate and write out the coadds.
                legacyhalos.coadds.tractor_coadds(onegal, P['targetwcs'], P['tims'], mods, P['version_header'],
                                                  prefix=prefix, brickname=brickname, survey=survey, mp=mp,
                                                  log=log, skycoadd=True)

        pdb.set_trace()

        if len(missing_ellipse(sample, clobber=True)) > 0:
            from legacyhalos.ellipse import legacyhalos_ellipse
            success = legacyhalos_ellipse(onegal, objid=prefix, objdir='.', ncpu=ncpu, 
                                          pixscale=PIXSCALE, debug=False, verbose=True)

        # Plots---
        legacyhalos.html.make_plots(onegal, analysisdir='.', htmldir='.',
                                    clobber=True, verbose=True)

        with open('CGCG004-096-ellipsefit.p', 'rb') as ff:
            res = pickle.load(ff)
        prof = ellipse_sbprofile(res)            
        with open('CGCG004-096-sbprofile.p', 'wb') as out:
            pickle.dump(prof, out)
            
        pdb.set_trace()
    
if __name__ == '__main__':
    main()

