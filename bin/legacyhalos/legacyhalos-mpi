#!/usr/bin/env python
"""MPI wrapper for the legacyhalos project.

legacyhalos-mpi --coadds

"""
import matplotlib
matplotlib.use('Agg')

import os, time, pdb
import numpy as np

def main():
    """Top-level wrapper.

    """
    import legacyhalos.io
    import legacyhalos.legacyhalos
    from legacypipe.runs import get_survey

    from legacyhalos.legacyhalos import ZCOLUMN, RACOLUMN, DECCOLUMN, DIAMCOLUMN

    basedir = legacyhalos.io.legacyhalos_dir()
    datadir = legacyhalos.io.legacyhalos_data_dir()
    htmldir = legacyhalos.io.legacyhalos_html_dir()

    args = legacyhalos.legacyhalos.mpi_args()

    #from legacypipe.survey import LegacySurveyData
    #from legacyhalos.misc import , ZCOLUMN
    #
    #from legacyhalos.mpi import (call_pipeline_coadds, call_custom_coadds, call_ellipse,
    #                             call_sersic, call_sky, call_htmlplots)

    if args.mpi:
        from mpi4py import MPI
        comm = MPI.COMM_WORLD
        rank, size = comm.rank, comm.size
    else:
        comm = None
        rank, size = 0, 1

    # Read and broadcast the sample.
    sample, fullsample = None, None
    if rank == 0:
        print('$LEGACYHALOS_DIR={}'.format(basedir))
        print('$LEGACYHALOS_DATA_DIR={}'.format(datadir))
        print('$LEGACYHALOS_HTML_DIR={}'.format(htmldir))
        #sample = legacyhalos.legacyhalos.read_redmapper(first=args.first, last=args.last,
        #                                                verbose=args.verbose, satellites=False)
        #if len(sample) == 0:
        #    return

        # For the custom coadds and build_catalog steps we need the satellites, too.
        if args.coadds or args.build_catalog or args.build_refcat:
            sample, fullsample = legacyhalos.legacyhalos.read_redmapper(
                first=args.first, last=args.last, verbose=args.verbose,
                satellites=True)
        else:
            sample = legacyhalos.legacyhalos.read_redmapper(
                first=args.first, last=args.last, verbose=args.verbose)

        pdb.set_trace()
        
    if comm is not None:
        sample = comm.bcast(sample, root=0)
        fullsample = comm.bcast(fullsample, root=0)

    # Building the web-page and integrating the ellipse-fitting results work on
    # the full sample, so do that here and then return.
    if args.htmlindex and rank == 0:
        intflux = legacyhalos.legacyhalos.read_integrated_flux(first=args.first, last=args.last,
                                                               verbose=args.verbose)
        legacyhalos.legacyhalos.make_html(sample, intflux=intflux, survey=None, pixscale=args.pixscale,
                                          zcolumn=ZCOLUMN, nproc=args.nproc, clobber=args.clobber,
                                          makeplots=False, verbose=args.verbose, htmldir=args.htmldir)
        return

    if args.build_refcat or args.integrate and rank == 0:
        if args.build_refcat:

            pdb.set_trace()
        if args.integrate:
            import legacyhalos.integrate
            results = legacyhalos.integrate.integrate(
                sample, nproc=args.nproc, verbose=args.verbose, clobber=args.clobber)
        return

    # Determine how many more galaxies we need to analyze and divide them across
    # ranks.
    if rank == 0:
        if args.build_catalog:
            print('Write me!')
            pass
        else:
            suffix, groups, _, fail = legacyhalos.legacyhalos.missing_files(args, sample, size)
            #groups[0] = groups[0][32:]
    else:
        groups, suffix = [], ''

    if comm is not None:
        groups = comm.bcast(groups, root=0)
        suffix = comm.bcast(suffix, root=0)

    if rank == 0:
        ntodo = len(np.hstack(groups))
        print('{} left to do: {} / {} divided across {} rank(s).'.format(
            suffix.upper(), ntodo, len(sample), size), flush=True)
        
    # Wait for all ranks to catch up.
    if comm is not None:
        comm.barrier()

    if len(groups[rank]) == 0:
        print('{} for all {} galaxies on rank {} are complete!'.format(
            suffix.upper(), len(sample), rank), flush=True)
        if rank == 0 and args.count and args.debug:
            if len(fail[rank]) > 0:
                print('{} failures: {} / {}'.format(suffix.upper(), len(fail[rank]), len(sample)), flush=True)
                galaxy, galaxydir = legacyhalos.legacyhalos.get_galaxy_galaxydir(sample[fail[rank]])
                for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir), sample[fail[rank]][DIAMCOLUMN]):
                    print('  {} {} (z={:.3f})'.format(ii, dd, diam))
        return
    else:
        if not args.build_catalog:
            print(' Rank {}: {} galaxies left to do.'.format(rank, len(groups[rank])), flush=True)
        if rank == 0 and args.count:
            if args.debug:
                if len(fail[rank]) > 0:
                    print('{} failures: {} / {}'.format(suffix.upper(), len(fail[rank]), len(sample)), flush=True)
                    galaxy, galaxydir = legacyhalos.legacyhalos.get_galaxy_galaxydir(sample[fail[rank]])
                    for ii, dd, diam in zip(fail[rank], np.atleast_1d(galaxydir), sample[fail[rank]][DIAMCOLUMN]):
                        print('  {} {} (z={:.3f})'.format(ii, dd, diam))

                todo = np.hstack(groups)
                if len(todo) > 0:
                    print('{} todo: {} / {}'.format(suffix.upper(), len(todo), len(sample)), flush=True)
                    galaxy, galaxydir = legacyhalos.legacyhalos.get_galaxy_galaxydir(sample[todo])
                    for ii, dd, diam in zip(todo, np.atleast_1d(galaxydir), sample[todo][DIAMCOLUMN]):
                        print('  {} {} (z={:.3f})'.format(ii, dd, diam))
            return
        
    # Wait for all ranks to catch up.
    if comm is not None:
        comm.barrier()

    # Loop on the remaining objects.
    print('Starting {} {} on rank {} with {} cores on {}'.format(
        len(groups[rank]), suffix.upper(), rank, args.nproc, time.asctime()),
        flush=True)

    # Build the SGA only on rank 0 in order to avoid memory problems--
    if args.build_catalog:
        pdb.set_trace()

    # The rest of the pipeline--
    tall = time.time()
    for count, ii in enumerate(groups[rank]):
        onegal = sample[ii]
        galaxy, galaxydir = legacyhalos.legacyhalos.get_galaxy_galaxydir(onegal)
        if not os.path.isdir(galaxydir):
            os.makedirs(galaxydir, exist_ok=True)

        #if (count+1) % 10 == 0:
        print('Rank {:03d} ({} / {}): {} (index {})'.format(
            rank, count+1, len(groups[rank]), galaxydir, ii), flush=True)

        if args.debug:
            logfile = None
        else:
            logfile = os.path.join(galaxydir, '{}-{}.log'.format(galaxy, suffix))
            #print('Logging to {} '.format(logfile), flush=True)

        # Need the cluster "radius" to build the coadds.
        radius_mosaic_arcsec = onegal[DIAMCOLUMN] # [arcsec]

        ## custom sky-subtraction
        #if args.ubercal_sky:
        #    radius_mask_arcsec = onegal[DIAMCOLUMN] * 60 / 2.0
        #    subsky_radii = (radius_mask_arcsec, 1.5*radius_mask_arcsec, 2*radius_mask_arcsec)
        #else:
        #    subsky_radii = None
        subsky_radii = None

        run = legacyhalos.io.get_run(onegal, racolumn=RACOLUMN, deccolumn=DECCOLUMN)
        survey = get_survey(run, output_dir=galaxydir)

        if args.coadds:
            from legacyhalos.mpi import call_custom_coadds
            if args.sdss:
                pass
                #err = legacyhalos.sdss.download(sample, pixscale=args.sdss_pixscale, clobber=args.clobber)
                #pdb.set_trace()
            else:
                # Write out the individual galaxies for this mosaic.
                thissample = fullsample[np.where(onegal['MEM_MATCH_ID'] == fullsample['MEM_MATCH_ID'])[0]]
                samplefile = os.path.join(galaxydir, '{}-redmapper-sample.fits'.format(galaxy))
                print('Writing {} galaxy(ies) to {}'.format(len(thissample), samplefile))
                thissample.write(samplefile, overwrite=True)

                call_custom_coadds(onegal, galaxy, survey, run, radius_mosaic_arcsec, nproc=args.nproc,
                                   pixscale=args.pixscale, racolumn=RACOLUMN, deccolumn=DECCOLUMN,
                                   largegalaxy=False, pipeline=False, custom=True,
                                   apodize=False, unwise=args.unwise, force=args.force, plots=False,
                                   verbose=args.verbose, cleanup=args.cleanup, write_all_pickles=True,
                                   #subsky_radii=subsky_radii,
                                   just_coadds=args.just_coadds, no_gaia=False, no_tycho=False,
                                   require_grz=True, debug=args.debug, logfile=logfile)

        pdb.set_trace()
                
        if args.custom_coadds or args.htmlplots:
            if not legacyhalos.io.check_and_read_ccds(galaxy, survey, debug=args.debug, logfile=logfile):
                continue

        if args.custom_coadds:
            call_custom_coadds(onegal, galaxy, radius_mosaic_arcsec, survey,
                                pixscale=args.pixscale, nproc=args.nproc, debug=args.debug,
                                logfile=logfile, sdss=args.sdss, sdss_pixscale=args.sdss_pixscale)
                    
        if args.ellipse:
            call_ellipse(onegal, galaxy=galaxy, galaxydir=galaxydir, pixscale=args.pixscale,
                         nproc=args.nproc, verbose=args.verbose, debug=args.debug,
                         logfile=logfile, zcolumn=ZCOLUMN)
                        
        if args.sersic:
            call_sersic(onegal, galaxy, galaxydir, args.seed, args.verbose,
                         args.debug, logfile)
            
        if args.sky:
            call_sky(onegal, galaxy, galaxydir, survey, args.seed, args.nproc,
                      args.pixscale, args.verbose, args.debug, logfile)

        if args.htmlplots:
            call_htmlplots(Table(onegal), galaxy, survey, args.pixscale, args.nproc,
                           args.debug, args.clobber, args.verbose, args.ccdqa, logfile,
                           ZCOLUMN, args.htmldir)

    if rank == 0:
        print('Finished {} {} at {} after {:.3f} minutes'.format(
            ntodo, suffix.upper(), time.asctime(), (time.time() - tall) / 60 ), flush=True)
        _, groups = legacyhalos.io.missing_files_groups(args, sample, size, args.htmldir)
        if len(groups) > 0:
            stilltodo = len(np.hstack(np.atleast_1d(groups)))
        else:
            stilltodo = 0
        print('{} left to do: {} / {}.'.format(suffix.upper(), stilltodo, ntodo), flush=True)

if __name__ == '__main__':
    main()
